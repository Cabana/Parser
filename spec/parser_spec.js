// Generated by CoffeeScript 1.6.2
(function() {
  describe('String', function() {
    describe('#wrapInBraces', function() {
      return it('should wrap the string in braces', function() {
        return expect('foo'.wrapInBraces()).toBe('{foo}');
      });
    });
    describe('#replaceSquareBracketsWithBraces', function() {
      return it('replace all square brackets with braces', function() {
        return expect('[foo]'.replaceSquareBracketsWithBraces()).toBe('{foo}');
      });
    });
    return describe('#removeWhitespace', function() {
      return it('removes all whitespace from a string', function() {
        return expect('foo bar'.removeWhitespace()).toBe('foobar');
      });
    });
  });

  describe('Parser', function() {
    describe('without default values', function() {
      beforeEach(function() {
        return this.parser = new Parser;
      });
      it('parses an empty string into an empty object', function() {
        return expect(this.parser.parse('')).toEqual({});
      });
      it('parses a single key:value pair', function() {
        return expect(this.parser.parse('key:value')).toEqual({
          key: 'value'
        });
      });
      it('parses multiple key:value pairs', function() {
        return expect(this.parser.parse('foo:value, bar:value')).toEqual({
          foo: 'value',
          bar: 'value'
        });
      });
      it('parses nested key:value pairs', function() {
        return expect(this.parser.parse('foo:[bar:value]')).toEqual({
          foo: {
            bar: 'value'
          }
        });
      });
      it('parses nested key:value pairs along with simple pairs', function() {
        return expect(this.parser.parse('foo:[bar:value], test:mega')).toEqual({
          foo: {
            bar: 'value'
          },
          test: 'mega'
        });
      });
      it('parses multiple nested pairs', function() {
        return expect(this.parser.parse('foo:[bar:value], foo:[bar:value]')).toEqual({
          foo: {
            bar: 'value'
          },
          foo: {
            bar: 'value'
          }
        });
      });
      it('parses pairs with multiple levels of nesting', function() {
        return expect(this.parser.parse('foo:[bar:[test:mega]]')).toEqual({
          foo: {
            bar: {
              test: 'mega'
            }
          }
        });
      });
      it('parses nested pairs alongside simple pairs', function() {
        return expect(this.parser.parse('foo:[bar:value], test:mega')).toEqual({
          foo: {
            bar: 'value'
          },
          test: 'mega'
        });
      });
      it('converts integers', function() {
        expect(this.parser.parse('foo:1')).toEqual({
          foo: 1
        });
        expect(this.parser.parse('foo:88')).toEqual({
          foo: 88
        });
        return expect(this.parser.parse('foo:foo1')).toEqual({
          foo: 'foo1'
        });
      });
      it('converts booleans', function() {
        expect(this.parser.parse('foo:true')).toEqual({
          foo: true
        });
        return expect(this.parser.parse('foo:false')).toEqual({
          foo: false
        });
      });
      it('parses undefined values', function() {
        return expect(this.parser.parse('key')).toEqual({
          key: 'undefined'
        });
      });
      it('parses multiple undefined values', function() {
        return expect(this.parser.parse('foo, bar')).toEqual({
          foo: 'undefined',
          bar: 'undefined'
        });
      });
      it('parses nested undefined values', function() {
        return expect(this.parser.parse('foo:[bar]')).toEqual({
          foo: {
            bar: 'undefined'
          }
        });
      });
      it('also parses then a value is kinda funky', function() {
        expect(this.parser.parse('foo:.+')).toEqual({
          foo: '.+'
        });
        expect(this.parser.parse('foo:.+@.+\..+')).toEqual({
          foo: '.+@.+\..+'
        });
        return expect(this.parser.parse('foo:\\d{8}')).toEqual({
          foo: '\\d{8}'
        });
      });
      it('can be used to generate a regex', function() {
        var regex;

        regex = new RegExp(this.parser.parse("foo:\\d{8}").foo);
        return expect(regex.test('12345678')).toBe(true);
      });
      return it('parses a slightly more complex string', function() {
        var result, string;

        string = 'format:[email, custom:[cpr:\\d{6}-\\d{4}], required:.+], length:[min:3, max:255], allowEmpty: true';
        result = {
          format: {
            email: 'undefined',
            custom: {
              cpr: '\\d{6}-\\d{4}'
            },
            required: '.+'
          },
          length: {
            min: 3,
            max: 255
          },
          allowEmpty: true
        };
        return expect(this.parser.parse(string)).toEqual(result);
      });
    });
    describe('with default values', function() {
      describe('added upon instantiation', function() {
        it('parses with default values', function() {
          var parser;

          parser = new Parser({
            foo: 'bar'
          });
          return expect(parser.parse('foo')).toEqual({
            foo: 'bar'
          });
        });
        it('parses with multiple default values', function() {
          var parser;

          parser = new Parser({
            foo: 'bar',
            bar: 'booz'
          });
          return expect(parser.parse('foo, bar')).toEqual({
            foo: 'bar',
            bar: 'booz'
          });
        });
        it('does not overwrite values given in the string', function() {
          var parser;

          parser = new Parser({
            foo: 'bar'
          });
          return expect(parser.parse('foo:mads')).toEqual({
            foo: 'mads'
          });
        });
        it('parses nested values with default values', function() {
          var parser;

          parser = new Parser({
            bar: 'baz'
          });
          return expect(parser.parse('foo:[bar]')).toEqual({
            foo: {
              bar: 'baz'
            }
          });
        });
        it('parses with multiple values where some of them have nested values', function() {
          var parser;

          parser = new Parser({
            bar: 'baz',
            two: 'mads'
          });
          return expect(parser.parse('one:[bar], two')).toEqual({
            one: {
              bar: 'baz'
            },
            two: 'mads'
          });
        });
        it('parses multiple levels deep', function() {
          var parser;

          parser = new Parser({
            bar: 'baz',
            three: 'mads'
          });
          return expect(parser.parse('one:[bar, two:[three]]')).toEqual({
            one: {
              bar: 'baz',
              two: {
                three: 'mads'
              }
            }
          });
        });
        return it('only adds values where they need to be', function() {
          var parser;

          parser = new Parser({
            foo: 'foo'
          });
          expect(parser.parse('foo, bar')).toEqual({
            foo: 'foo',
            bar: 'undefined'
          });
          return expect(parser.parse('bar, foo')).toEqual({
            bar: 'undefined',
            foo: 'foo'
          });
        });
      });
      return describe('adding default values after instantiation', function() {
        return describe('#addDefaultValue', function() {
          it('parses with the new default value', function() {
            var parser;

            parser = new Parser;
            parser.addDefaultValue('foo', 'bar');
            return expect(parser.parse('foo')).toEqual({
              foo: 'bar'
            });
          });
          return it('still works with value defined upon instantiation', function() {
            var parser;

            parser = new Parser({
              foo: 'bar'
            });
            parser.addDefaultValue('baz', 'booz');
            return expect(parser.parse('foo, baz')).toEqual({
              foo: 'bar',
              baz: 'booz'
            });
          });
        });
      });
    });
    return describe('a real world example', function() {
      beforeEach(function() {
        this.parser = new Parser({
          email: '.+@.+\\..+'
        });
        this.parser.addDefaultValue('cpr', '\\d{6}-\\d{4}');
        this.string = 'format:[email, custom:[cpr]], length:[min:3, max:255], allowEmpty: true';
        return this.result = {
          format: {
            email: '.+@.+\\..+',
            custom: {
              cpr: '\\d{6}-\\d{4}'
            }
          },
          length: {
            min: 3,
            max: 255
          },
          allowEmpty: true
        };
      });
      it('parses it', function() {
        return expect(this.parser.parse(this.string)).toEqual(this.result);
      });
      return describe('the result', function() {
        return it('can be used to do regex matching', function() {
          var regex;

          regex = new RegExp(this.result.format.email);
          return expect(regex.test('david.pdrsn@gmail.com')).toEqual(true);
        });
      });
    });
  });

}).call(this);
