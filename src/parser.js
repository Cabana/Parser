// Generated by CoffeeScript 1.6.2
(function() {
  Array.prototype.clean = function(deleteValue) {
    var i;

    i = 0;
    while (i < this.length) {
      if (this[i] === deleteValue) {
        this.splice(i, 1);
        i--;
      }
      i++;
    }
    return this;
  };

  String.prototype.wrapInBraces = function() {
    return this.replace(/^/, '{').replace(/$/, '}');
  };

  String.prototype.replaceSquareBracketsWithBraces = function() {
    return this.replace(/\[/g, '{').replace(/\]/g, '}');
  };

  String.prototype.removeWhitespace = function() {
    return this.replace(/\s+/g, '');
  };

  this.Parser = (function() {
    function Parser(defaults) {
      this.defaults = defaults;
    }

    Parser.prototype.parse = function(string) {
      var result;

      result = {};
      if (string === '') {
        return result;
      }
      string = this._prepareString(string);
      return this._toJSON(string);
    };

    Parser.prototype.addDefaultValue = function(value, key) {
      this.defaults || (this.defaults = {});
      return this.defaults[value] = key;
    };

    Parser.prototype._prepareString = function(string) {
      string = string.removeWhitespace();
      if (this.defaults) {
        string = this._applyOptionValues(string);
      }
      string = this._setUndefinedValues(string);
      string = this._wrapWordsInQuotes(string);
      return string;
    };

    Parser.prototype._applyOptionValues = function(string) {
      var index, newString, nextWord, splitString, word, _i, _len;

      newString = '';
      splitString = this._splitIntoWords(string);
      for (index = _i = 0, _len = splitString.length; _i < _len; index = ++_i) {
        word = splitString[index];
        nextWord = splitString[index + 1];
        if (this.defaults[word] && nextWord !== ':') {
          word += ":" + this.defaults[word];
        }
        newString += word;
      }
      return newString;
    };

    Parser.prototype._setUndefinedValues = function(string) {
      var index, newString, nextWord, part, prevWord, splitString, word, _i, _j, _len, _len1, _ref;

      splitString = this._splitIntoWords(string);
      for (index = _i = 0, _len = splitString.length; _i < _len; index = ++_i) {
        word = splitString[index];
        nextWord = splitString[index + 1];
        prevWord = splitString[index - 1];
        if (/\]+/.test(nextWord) && prevWord !== ':' || nextWord === ',' || nextWord === void 0 && !/\]+/.test(word)) {
          splitString[index] += ":undefined";
        }
      }
      string = splitString.join('');
      newString = '';
      _ref = string.split(/(\[|,|\])/);
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        part = _ref[_j];
        if (/.*:.*:.*/.test(part)) {
          part = part.replace(':undefined', '');
        }
        newString += part;
      }
      return newString;
    };

    Parser.prototype._splitIntoWords = function(string) {
      return split(string, /(:\[?|\]+,?|,)/).clean('');
    };

    Parser.prototype._wrapWordsInQuotes = function(string) {
      var index, splitString, word, _i, _len;

      splitString = this._splitIntoWords(string);
      for (index = _i = 0, _len = splitString.length; _i < _len; index = ++_i) {
        word = splitString[index];
        if (!(word === ':' || /\]+/.test(word) || word === ':[' || word === ',')) {
          if (/^\d+$/.test(word)) {
            splitString[index] = parseInt(word);
          } else if (word === 'true') {
            splitString[index] = true;
          } else if (word === 'false') {
            splitString[index] = false;
          } else {
            splitString[index] = "\"" + word + "\"";
          }
        }
      }
      return splitString.join('');
    };

    Parser.prototype._toJSON = function(string) {
      if (!/\.*:\.*/.test(string)) {
        string += ":\"undefined\"";
      }
      string = string.replaceSquareBracketsWithBraces().wrapInBraces();
      string = string.replace(/\\/g, "\\\\");
      return JSON.parse(string);
    };

    return Parser;

  })();

}).call(this);
